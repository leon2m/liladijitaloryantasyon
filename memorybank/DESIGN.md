# Lila Explorer - Design & Architecture

This document outlines the design principles, architecture, and core functionality of the Lila Explorer application.

## 1. Project Goal

Lila Explorer is a comprehensive digital assessment platform designed for recruitment and professional development. It provides users with a suite of psychometric tests, delivers detailed, AI-enhanced reports, and guides them through a structured orientation process.

## 2. Core Features

- **Psychometric Assessments**: Three distinct tests:
    1.  **Belbin Team Roles**: Identifies an individual's natural roles within a team.
    2.  **Social Color Personality**: Reveals communication styles and core motivations.
    3.  **Learning Styles**: Determines if a user learns best visually, audibly, or kinesthetically.
- **AI-Powered Reporting**: After each test, a simulated AI generates a personalized interpretation of the user's results.
- **Guided Orientation**: A multi-step onboarding module to introduce users to the company culture and prepare them for assessments.
- **Device-Based Authentication**: A secure, password-less login system using a unique, one-time-generated "recovery code."
- **Results Archive**: A history page where users can review all previously completed test results.
- **User Support Chatbot**: A simple, keyword-driven chatbot to answer common user questions.

## 3. Technology Stack & Architecture

- **Frontend Framework**: React 19 with TypeScript.
- **Routing**: `react-router-dom` for client-side navigation.
- **Styling**: Tailwind CSS for utility-first styling, supplemented with global custom styles for theme consistency (e.g., animated gradient background, glassmorphism cards).
- **Data Visualization**: `recharts` for rendering dynamic charts on the results page.
- **Dependencies**: Managed via an `importmap` in `index.html` to load ES modules directly from a CDN (esm.sh), simplifying the build process.

### Backend Simulation

The entire backend is currently simulated within the frontend using `services/apiService.ts`.

- **Database**: `localStorage` is used as a mock database to persist user data, device tokens, recovery codes, and test results.
- **API Logic**: The `apiService` exports functions that mimic REST API calls (e.g., `bootstrap`, `getMe`, `submitTest`). These functions include artificial delays to simulate network latency.
- **AI Simulation**: The AI interpretation is generated by a hardcoded string template function (`generateInterpretation`) within the `apiService`, which mimics a call to an AI service like the Gemini API.

## 4. Application Structure

The project is organized into logical directories to promote separation of concerns:

- **/components**: Reusable React components used across multiple pages (e.g., `Sidebar`, `Chatbot`, `QRCode`).
- **/data**: Static JSON files that serve as the content database for tests, chatbot rules, and orientation steps.
- **/pages**: Top-level components that correspond to specific routes/views (e.g., `Welcome`, `TestRunner`, `Results`).
- **/services**: Modules responsible for business logic and data fetching (`apiService`, `testService`).
- **/types.ts**: A central file for all TypeScript type definitions.

## 5. Key UI/UX Concepts

- **Aesthetic**: Modern, clean, and professional. The "glassmorphism" effect (`glass-card`) on main containers creates a sense of depth over the animated gradient background.
- **Primary Call-to-Action**: A vibrant green (`btn-primary`) is used for all primary buttons, ensuring a clear and consistent user journey.
- **Layout**:
    - **Unauthenticated**: Centered, single-column layout focusing on the task at hand (registration or recovery).
    - **Authenticated**: A two-column layout with a fixed navigation `Sidebar` on the left and a main content area on the right. This provides persistent navigation and a stable user experience.
- **User Feedback**: Loading spinners and disabled button states are used during asynchronous operations to provide clear feedback to the user, preventing duplicate actions and reducing uncertainty.

## 6. Authentication Flow (Device Pairing)

The application uses a password-less system designed for simplicity and security within its context.

1.  **Bootstrap**: A new user provides their name on the `Welcome` page.
    - `apiService.bootstrap` is called.
    - A new `user_id`, `device_token`, and `recovery_code` are generated.
    - The `device_token` is stored in `localStorage` on the current device, effectively "logging the user in."
2.  **Recovery Code**: The user is shown their unique `recovery_code` on the `RecoveryCode` page. This is their permanent key to their account.
3.  **Session Persistence**: As long as the `device_token` exists in `localStorage`, the user is considered authenticated on that device.
4.  **Account Recovery**: On a new device, the user selects "Enter Recovery Code."
    - They input their `recovery_code`.
    - `apiService.recover` validates the code and retrieves the associated `user_id`.
    - `apiService.pair` is called with the `user_id`. It generates a **new** `device_token` for the new device, stores it in `localStorage`, and logs the user in.
